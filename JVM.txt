相关书籍：《深入理解Java虚拟机》，《实战Java虚拟机》
知识点梳理：
1.基础系列：
	1）JDK与JRE：
		a. JRE (Java Runtime Environment):仅包含运行Java程序的必须组件，包括Java虚拟机及Java核心类库等。
		b. JDK（Java Development Kit):除了包含JRE之外，还附带了一系列开发、诊断工具。


	2）JDK与J2SE：
		J2SE是Java三大技术体系之一（J2SE, J2EE, J2ME），在JDK1.6发布的时候，将命名更改为Java SE 6, Java EE 6, Java ME 6。
		a. J2SE 标准版技术体系，包含了构成Java语言的核心类，例如：数据库连接，网络编程，接口定义等。主要用于桌面应用软件的编程。
		b. J2EE 企业版技术体系，除了包含J2SE中的类，还包含用于开发企业级应用的类，比如：Servlet,JSP,EJB等。主要用于分布式网络程序的开发，比如电子商务网站等。
		c. J2ME 嵌入式技术体系，包含J2SE中的一部分类。主要用于消费类电子产品的软件开发，例如：手机、PDA、寻呼机等。
	
	
	3）什么是虚拟机？
		Java可以在服务端的不同系统运行是因为，Java与其他语言不同，Java并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，称之为字节码。因此Java程序要运行，都得先编译成字节码文件之后才能运行。而各系统是无法了解字节码文件的内容的，需要JVM对字节码文件进行解析，并翻译成各操作系统能理解的机器码。！！！！！Java虚拟机运行的是字节码文件（class文件）！！！！
	Source Code ——> Byte Code --> JVM -->不同系统的机器代码
	

	4）从源代码到机器码
		a. 编译器可以分为：
			I. 前端编译器- 源代码到字节码： Sun 的Javac, Eclipse JDT中的增量式编译器（ECJ）
			在JDK安装目录里有一个javac工具，就是它将Java代码翻译成字节码，它被叫做编译器。相对于其他编译器，它处于编译前期，因此被称为前端编译器。运行javac命令的过程就是javac编译器解析Java源代码，并且生成字节码文件的过程。
			javac编译器的处理过程可以分为下面四个阶段：
				1.词法、语法分析。JVM在这个阶段会对源代码的字符进行一次扫面，最终生成一个抽象的语法树。（搞懂代码到底想要干嘛）
				2.填充符号表。类会互相引用，但是在编译阶段，无法确定其地址，因此会使用一个符号来替代。即对抽象的类或者接口进行符号填充，等到类加载阶段JVM会将符号替换成具体的内存地址。
				3.注解处理。JVM对注解进行分析，根据注解的作用将其还原成具体的指令集。
				4.分析与字节码生成。JVM根据上面几个阶段分析的结果，进行字节码生成，输出最终的class文件。
				
			II. JIT编译器（Just-in-Time）- 从字节码到机器码：HotSpot VM的 C1,C2编译器
				源代码转化成字节码之后有两个选择：使用Java解释器解释执行字节码（启动速度快，运行速度慢）或者用JIT编译器将字节码转化成本地机器码（启动速度慢，运行速度快）。解释器不用将字节码都转化为机器码，因此少了优化的时间，但机器码运行效率比Java解释器高。因此，在实：际情况下，为了提高运行速度及效率，会采用两种结合的方式进行Java代码的编译执行。
				在HotSpot虚拟机内置了两个即时编译器，分别为Client Complier和Server Compiler。两种编译器衍生出两种不同的编译模式，分别为C1编译模式，C2编译模式。两种编译模式的区别：C1编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控逻辑。而C2编译模式也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。
				如何选择编译模式？对于HotSpot虚拟机来说，有三种运行模式可选：1.混合模式（Mixed Mode)，即C1、C2混合使用，为默认的运行模式。如果想单独使用C1或者C2，用-client / -server打开即可；2.解释模式（Interpreted Mode），即所有代码都解释执行，但是无法编译时也会解释执行，使用-Xcomp打开这种模式；3.编译模式（Compiled Mode)，优先采用编译，但无法编译时也会解释执行，使用-Xcomp打开。
				
			III. AOT编译器 - 源代码到机器码：GNU Compiler for the Java(GCT), Excelsior JET.
				AOT编译器的基本思想是：在程序执行前生成Java方法的本地代码，以便在程序运行时直接使用本地代码。但是Java语言的动态特性会影响Java程序静态编译代码的质量。所以AOT的编译质量比不上JIT。其存在的目的是避免JIT编译器的运行时性能消耗或者内存消耗，或者避免解释程序的早期性能开销。编译代码速度：解释执行>AOT>JIT；编译质量：JIT>AOT>解释执行。AOT的存在时JVM牺牲质量换取性能的策略。


	5)字节码文件结构 - 字节码格式规范：《Java虚拟机规范》规定了虚拟机结构、class类文件结构、字节码指令等内容。
		字节码文件结构是一组以8位字节为基础的二进制流，各数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。在字节码结构中，有两种最基本的数据类型了，哎表示字节码文件格式：无符号数和表。
		a.无符号数属于最基本的数据类型，以u1,u2,u4,u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。
		b.表是由多个无符号数或者其他表作为数据项构成的复合数据类型。用于描述有层次关系的复合结构的数据。一张完整的表分为以下七个部分，这七部分组成了一个完整的Class字节码文件：
			I.魔数与Class文件版本:
				魔数：Class文件的第1-4个字节代表文件的魔数，唯一作用为确定这个文件是否能被虚拟机接受的Class文件，固定值为0xCAFEBEBE，如果不是，那么虚拟机会拒绝运行这个文件。
				Class文件版本：第5-6个字节代表Class文件的次版本号，编译该Class文件的JDK次版本号。第7-8个字节代表Class文件的主版本号。
			II.常量池：版本信息之后的为常量池信息
				常量池个数：之后的前2个字节
				常量池具体信息：常量池个数之后的不定长度数据。
			III.访问标志：常量池之后的两个字节代表类或者接口访问标记。（访问标志可能是由多个标志名称值进行或运算得出的）。
			VI.类索引、父类索引、接口索引：类索引及父类索引都是u2类型的数据，接口索引为u2类型的数据的集合。Class文件由这三项来确定类的继承关系。		
				类索引：用于确定本类的全限定名，类索引为0005即表示指向常量池中第5个常量。
				父类索引：用于确定本类的父类的全限定名。
				接口索引：用来描述哪个类实现了哪些接口，第一项为u2类型的接口计数器，表示索引表的容量，接着为所有接口信息。如果没有实现接口，计数器的值为0，后面的接口索引表则不占用任何字节。
			V.字段表集合：用于描述接口或者类中声明的变量。类接口集合后的2个字节为字段计数器，表示总共有几个属性字段。之后为具体的属性数据。
			IV.方法表集合：字段表之后的2个字节为方法计数器，表示类中有几个方法。字段计数器之后才是具体的方法数据。
			IIV.属性表集合：类中属性的属性表。


	6)Java虚拟机内存结构 - 《Java虚拟机规范》：运行时数据区
---------------运行字节码过程： 加载字节码文件->存入JVM内存空间->初始化->结果------------		Java类信息存储在方法区。创建对象的话，对象数据存放在Java堆。调用方法就用到PC寄存器、JVM栈、本地方法栈等结构。	


		A.公有部分：Java堆，方法区，常量池
			a.Java堆:JVM划分出来一块区域专门用于Java（几乎所有）实例对象的内存分配。（一些小对象会直接在栈上分配）。根据存活时间不同，Java堆被分为年轻代和老年代两个区：年轻代-Eden区、From Survivor 0, To Survivor 1区。
				ps：当有对象需要分配时，一个对象永远被分配在年轻代的Eden区，等到Eden区不够时，JVM会启动垃圾回收机制，Eden区中没有被引用的对象的内存就会被回收，而存活时间比较长的对象会进入到老年代。在JVM中有一个名为 -XX:MaxTenuringThreshold的参数专门用来设置晋升到老年代需要经历的GC次数。在年轻代的对象经过了指定次数的GC后，将在下次GC时进入老年代。	
				为什么Java堆要进行这样的区域划分？虚拟机中的对象肯定有存活时间长短不一的对象。如果混在一起，存活时间短的对象有很多，那么会导致频繁的垃圾回收。在垃圾回收时不得不对所有内存进行扫面，而有一部分对象存活时间很长，如果进行扫面的话就是浪费时间，因此为了提高垃圾回收效率，分区理所当然。默认虚拟机配置为Eden:from:to = 8:1:1			
			b.方法区：存储Java类字节码数据的一块区域，存储了每一个类的结构信息，比如：常量池、字段和方法数据。在1.7版本的HotSpot虚拟机中方法区被称为永久代）Permanent Space），在JDK1.8中被称之为MetaSpace。
			c.常量池：其实是存放在方法区的。
		B.私有部分:PC寄存器、Java虚拟机栈、本地方法战
			a.PC寄存器（Program Counter）：保存线程当前正在执行的方法。如果方法不是native方法，则保存JVM正在执行的字节码指令地址；否则，保存的值就为undefined。任意时刻，JVM线程只会执行一个方法的代码，这个被线程执行的方法被称为该线程的当前方法，其地址被存在PC寄存器中。
			b.JVM栈：与线程同时创建，用来存储栈帧，及存储局部变量与一些过程结果的地方。存储的数据包括；局部变量表、操作数栈。
			c.本地方法栈：如果JVM用其他语言来实现指令集解释器时会用到。如果虚拟机不支持native方法，并且自己也不依赖传统栈的话，可以无需本地方法栈。

	
	7）JVM类加载机制：Java源码编译成字节码之后，虚拟机可以讲字节码文件读取进内存，从而进行解析、运行。JVM执行class字节码的过程有7个阶段：
			加载->验证->准备->解析->初始化->使用->卸载
		A.加载：把代码数据加载到内存中（JVM将字节码从各个位置转化为二进制字节流加载到内存中，并且为类的JVM的方法区创建对应的Class对象，该对象即为这个类各种数据的访问入口）
		B.验证：JVM加载完Class字节码文件并在方法区创建对应的Class对象后，JVM会启动对字节码流的校验。只有符合JVM字节码规范的文件才能被正确执行。过程大概分为下面几个类型：
			a.JVM规范校验：对字节流进行文件格式校验，判断是否符合JVM规范（见上文），是否能被当前版本的虚拟机处理。
			b.代码逻辑校验：JVM对代码组成的数据流和控制流进行校验，确保JVM运行该字节码文件后不会出现致命错误。
		C.准备：JVM为类变量分配内存并初始化。
			a.内存分配的对象：Java的变量有“类变量”和“类成员变量”，类变量指的是被static修饰的变量，其他所有类型的变量都属于类成员变量。在准备阶段，JVM只会为类变量分配内存（并不初始化）！！！类成员变量需要等到初始化阶段才开始内存分配。ps:如果一个变量杯static final修饰，那么在这准备阶段就会被赋予希望的值。
		D.解析：JVM针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。
		E.初始化（！！！）：JVM根据语句执行顺序对类对象进行初始化，一般来说，当JVM遇到一下情况会触发初始化：
			a.遇到new、getstatic、putstatic、invokestatic四条字节码指令时，如果类未进行初始化，则需要先触发其初始化。4条指令最常见的Java代码场景：使用new关键字实例话对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
			b.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			c.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则先触发其父类的初始化。
			d.虚拟机启动时，用户需要指定一个执行的主类（包含main（）方法那个类），虚拟机会先初始化这个主类（执行类构造器：按顺序收集类中所有的静态代码块和类变量赋值语句）。
			e.使用JDK1.7动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化则需要先触发其初始化。
		F.使用：JVM从入口方法开始执行用户的程序代码。
		G.卸载：程序代码执行完毕之后，JVM开始销毁创建的Class对象，最后负责运行的JVM退出内存。

	总结：类的执行顺序按照如下步骤：
		1.确定类变量的初始值。如果是final修饰的，直接初始成用户指定值。
		2.初始化入口方法：进入类加载的初始化阶段后，JVM寻找main方法入口，初始化main方法所在的整个类。对类进行初始化时，先会初始化类构造器，之后初始化对象构造器。
		3.初始化类构造器：JVM按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由JVM执行。
		4.初始化对象构造器：JVM按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，组成对象构造器，由JVM执行。
	ps:如果在初始化main方法所在类的时候遇到了其他类的初始化，应先加载对应的类，加载完成之后返回。
		

	8）JVM垃圾回收机制
		A.谁是垃圾？判断方法：
			a.引用计数法，对象被引用计数+1，除引用-1。存在问题：循环引用（只有各自引用）。
			b.GC Root Tracing算法：从GC Root出发，所有可达对象都是存活的对象，不可达的对象都是垃圾。GC Root集合是一组活跃引用的集合，通常包括：
				1.所有当前被加载的类
				2.Java类的引用类型静态变量
				3.Java类的运行时常量池里的引用类型常量
				4.VM的一些静态数据结构里指向GC堆里的对象的引用

		B.如何进行垃圾回收？三种垃圾回收算法：
			a.标记清除算法：在标记阶段，标记所有由GC Root触发的可达对象，所有未标记的对象就是垃圾对象。在清除阶段，清除所有未被标记的对象。问题：空间碎片问题，如果空间碎片过多会导致内存空间不足。适合存活对象多的情况，因为不需要移动。
			b.复制算法：将原有的内存空间分为两块，每次只使用一块。在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。清除正在使用的内存块中的所有对象，之后交换两块空间的角色，完成垃圾回收。缺点：内存空间折半，浪费内存。适合存活对象少的情况，因为没有碎片。
			c.标记压缩算法：标记清除法的优化版，需要两个阶段：标记结算、压缩阶段。标记阶段，从GC Root引用集合触发去标记所有对象；在压缩阶段，将所有存活对象压缩在内存的一边，之后清理边界外所有空间。
		C.分代算法（实际采用）：根据不同内存区域，采用不同的垃圾回收算法。例如：对于存活对象少的新生代区域，采用复制算法，复制少量对象即可完成垃圾回收，并且没有内存碎片。对于老年代这种存活对象多的区域，采用标记压缩算法或者标记清除算法，不需要移动太多内存对象。
			a.新生代采用复制算法，但是分为Eden区，from区，to区：新生代对象98%朝生夕死，不需要按照1:1分配空间。回收时，将Eden和Survivor中存活的对象一次性复制到另外一块Survivor空间上，清理掉Eden和用过的Survivor空间。空间利用率达90%。
		D.分区思想：将整个堆空间划分成连续不同小区间，每个区间都独立使用，独立回收。优点：可以控制一次回收多少个区间，比较好的控制GC时间。


	9）JVM垃圾回收器：串行回收器、并行回收器，CMS回收器，G1回收器
		A.串行回收器：使用单线程进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用不同的堆空间，分为新生代串行回收器和老年代串行回收器。
			a.新生代串行回收器 - 复制法：所有垃圾回收器中最古老的一种，也是JDK中最基本的垃圾回收器之一。在串行回收器进行垃圾回收时，会触发Stop-The-World现象，即其他线程都需要暂停，等待垃圾回收完成。在某些情况下，会造成比较糟糕的用户体验。用-XX:+UseSerialGC参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在Client模式下运行时，其默认使用该垃圾收集器。
			b.老年代串行回收器 - 标记压缩算法：只能串行、独占式地进行垃圾回收，因此会有较长时间的Stop-The-World发生。但老年代串行回收器的好处之一就是可以与多种新生代回收器配合使用。若要启用老年代串行回收器，可以尝试一下参数：
				1.-XX:UseSerialGC：新生代、老年代都使用的串行回收器。
				2.-XX:UseParNewGC:新生代使用ParNew回收器，老年代使用串行回收器。
				3.-XX:UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行回收器。

		B.并行回收器：使用多线程进行垃圾回收，对并行能力强的机器，可以有效缩短垃圾回收使用时间。根据作用内存区域不同可以分为：
			a.新生代ParNew回收器 - 复制法: 多线程化，因此在并发能力强的CPU上，会产生的停顿时间要短于串行回收器。但在单CPU或并发能力弱的系统中，并行回收器效果会因为线程切换表现得不如串行回收器。开启新生代ParNew回收器可以使用如下参数：
				1.-XX:+UseParNewGC:新生代使用ParNew回收器，老年代使用串行回收器。
				2.-XX:UseConcMarkSweepGC:新生代使用ParNew回收器，老年代使用CMS。
				3.-XXParallelGCThreads:指定ParNew回收器的工作线程数量
			b.新生代ParallelGC回收器 - 复制法：多线程、独占式手机器，也会导致Stop-The-World。与ParNew回收器很大不同为：非常注重系统的吞吐量--有一个自适应GC调节策略。可以使用-XX:+UseAdaptiveSizePolicy参数打开这个策略。在这个模式下，新生代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数都会被自动调节，已达到堆大小、吞吐量、停顿时间的平衡点。
			c.老年代ParallelOldGC回收器 - 标记压缩法，只有在JDK1.6中可食用：多线程并发、注重吞吐量的收集器，作用于老年代。参数--XX:ParallelGCThreads用于设置垃圾回收时的线程数量。

		C.CMS回收器（Concurrent Mark Sweep）- 标记清除算法：主要关注系统停顿时间，使用多线程并行回收。
			a.工作步骤：初始标记（独占系统资源）->并发标记->预清理->重新标记（独占系统资源）->并发清除->并发充值。CMS回收过程中，默认情况下会有预清理操作，可以关闭开关 -XX:CMSPrecleaningEnabled不进行预清理。（预处理刻意等待一次新生代GC的发生，再进行预处理）。
			b.主要参数：
				1.启用：-XX:+UseConcMarkSweepGC
				2.线程并发数量: -XX:ConcGCThreads 或 -XX:ParallelCMSThreads
				3.指定老年代空间使用阀值： -XX:CMSInitiatingOccupancyFraction 当老年代空间使用率达到这个阀值时，会执行一次CMS回收，不用等到内存不够才进行GC
				4.CMS在垃圾回收后进行一次内存碎片整理：-XX:+UseCMSCompactAtFullCollection 因为CMS回收器为标记清除算法，容易产生比较多内存碎片。
				5.设置多少次CMS回收后，进行内存压缩：-XX:CMSFullGCsBeforeCompaction
				6.CMS回收Perm区（持久代）：-XX:CMSClassUnloadingEnabled
			
		D.G1回收器（Garbage First）：JDK1.7中使用的全新垃圾回收器，为了取代CMS回收器。
	10)		a.独特的垃圾回收策略。从分代看，G1依然属于分代垃圾回收器，但是使用了分区算法，使得Eden区、From区、Survivor区和老年代等各内存不必连续。
			b.解释结构：G1回收器中，将一大块内存分为许多细小的区块，不要求内存是连续的。每个Region被标记了E（Eden）、S（Survivor）、O（Old）和H（Humongous，巨型对象），说明每个Region在运行时都充当了一种角色。当新建对象大小超过Region大小的一半的时候，直接在新的一个或多个连续Region中分配，并标记为H。
			c.对内存中一个Region大小可以通过-XX:G1HeapRegionSize参数指定，大小区间只能是1M、2M、4M、8M等2的幂次方。如果G1HeapRegionSize为默认值，即把设置的最小堆内存按照2048份均分，最后得到一个合理的大小。
			d.工作步骤，四个阶段：
				1.新生代GC：清空Eden区，将存活对象移动到Survivor区，部分年龄到了就移动到老年代。
				2.并发标记周期：初始标记（独占，引发一次新生代GC）、根区域扫描、并发标记、重新标记（独占）、独占清理（独占）、并发清理阶段。所有将要被回收的区域会被G1记录在一个Collection Set集合中。
				3.混合收集：针对Collection Set中的内存进行回收，因为垃圾比例高。在混合回收的时候，也会执行多次新生代GC和混合GC，从而进行内存回收。
				4.如需，可能进行FullGC：在回收阶段遇到内存不足时，会停止垃圾回收并进行一次FullGC。
			e.相关参数：
				1.启用：-XX:+UseG1GC
				2.设置目标最大停顿时间:-XX:MaxGCPauseMillis
				3.设置GC工作线程数量：-XX:ParallelGCThreads
				4.设置堆使用率触发并标记周期的执行：-XX:InitiatingHeapOccupancyPercent.


	10)垃圾回收的几种类型：
		A.Minor GC或Yong GC - 年轻代空间回收内存
			a.当JVM无法为一个新的对象分配空间时会触发Minor GC，比如当Eden区满了，故Eden区越小，越频繁执行Minor GC。
			b.当年轻代中的Eden区分配满的时候，年轻代中的部分对象会晋升到老年代，所以Minor GC后老年代的占用量通常会提高。
			c.所有的Minor GC都会触发Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都可以忽略不计，因为大部分区中的对象都能被认为是垃圾，永远也不会被复制到Survivor区或者老年代空间。若情况相反，即Eden区大部分新生对象不符合GC条件，那么Minor GC执行时暂停的时间将会长很多。
		B.Major GC或Old GC - 老年代空间回收内存
			a.很多Major GC右Major GC触发，所以大多情况下两种GC分离不太可能。
			b.Minor GC作用于年轻代，Major GC作用于老年代。分配对象内存时发现内存不够，会触发Minor GC，Minor GC会将对象移到老年代中。如果此时老年代空间不够，那么触发Major GC。因此Major GC很多情况下是由Minor GC引起的。
		C.Full GC：清理整个堆空间，包括年轻代、老年代和永久代（如有）。因此Full GC可以说是Minor GC和Major GC的结合。
			a.准备触发Minor GC时，如果发现年轻代的剩余空间比以往晋升空间小，则不会触发Minor GC而是转为触发Full GC。
			b.永久代分配空间但已没有足够空间时，也会触发Full GC。
		D.Stop-The-World：所有非垃圾回收线程都无法工作。Stop-The-World时间的长短将关系到应用程序的响应时间，因此在GC过程中，Stop-The-World的时间是一个非常重要的指标。

	
	11）堆栈空间配置
		A.堆配置:用-Xms设置堆的初始空间大小；用-Xmx设置堆的最大空间大小。
			a.年轻代：JDK1.8中，堆分为年轻代和老年代。参数-Xmn设置年轻代内存的大小。老年代的大小等于堆大小-年轻代大小。
				1.Eden区:年轻代中使用-XX:SurvivorRatio参数来设置eden/from = eden/to空间比例。
		B.永久代（JDK1.7）：所加载的类信息放在永久代中，用-XX:PermSize设置永久代初始大小，用-XX:MaxPermSize设置永久代最大大小。
		C.元空间（JDK1.8）：与永久代同作用。参数：-XX:MetaspaceSize 设置GC初始阀值（默认为20.8M）;-XX:MaxMetaspaceSize元空间最大大小，默认基本为机器的物理内存大小。
		D.栈空间：每个线程各自有一块区域，如果栈空间太小也会导致StackOverFlow异常。用-Xss参数设置栈空间大小。
		E.直接内存：JVM独立于堆内存的内存。使用-XX:MaxDirectMemorySize设置最大直接内存。若不设置，默认为最大堆空间，即-Xmx。

	总结：
		1.-Xms:初始堆大小
		2.-Xmx:最大堆空间
		3.-Xmn:设置新生代大小
		4.-XX:SurvivorRatio:设置新生代Eden空间和from/tokj的比例关系
		5.-XX:PermSize:方法区初始大小
		6.-XX:MaxPermSize:方法区最大大小
		7.-XX:MetaspaceSize:元空间GC阀值（JDK1.8）
		8.-XX:MaxMetaspaceSize:最大元空间大小（JDK1.8）
		9.-Xss:栈大小
		10.-XX:MaxDirectMemorySize:直接内存大小，默认为最大堆空间


	12）查看JVM参数：显式参数和隐式参数
		A.打印显式参数：-XX:+PrintVMOptions 打印虚拟机接收到的命令行显式参数
		B.打印显式隐式参数：-XX:+PrintCommandLineFlags 打印传递给虚拟机的显式和隐式参数
		C.打印所有系统参数：-XX:+PrintFlagsFinal 打印所有的系统参数的值


		
	13）追踪类信息
		A.跟踪类的加载和卸载 -verbose:class ：
		B.跟踪类的加载 -XX:+TraceClassLoading ：
		C.跟踪类的卸载 -XX:+TraceClassUnloading ：
		D.-XX:+PrintClassHistogram :显示类信息柱状图。该参数遇到Ctrl-Break后打印实例的柱状信息，与jmap-histo功能相同


	14）GC（Garbage Collection）日志配置
		A.打印GC日志: -XX:PrintGC
		B.打印详细GC日志：-XX:PrintGCDetails 查看详细GC日志，比格犬在退出之前打印整个堆的详细信息。
		C.GC前后打印堆信息： -XX:PrintHeapAtGC：在GC前后打印堆信息
		D.打印GC发生的时间: -XX:PrintGCTimesStamps :在GC日志的前面加上一个时间戳，表示JVM启动后到现在逝去的时间。
		E.打印应用程序的执行时间: -XX:+PrintGCApplictionConcurrentTime
		F.打印应用由于GC而产生的停顿时间: -XX:+PrintGCApplicationStoppedTime
		G.保存GC日志： -Xloggc：将GC日志输出到文件中保存起来



	15）JDK性能监控命令
		A.查看虚拟机进程：jps命令：可以列出所有的Java进程。如果jps不加参数，列出Java程序的进程ID及Main 函数短名称，也可以参数自定义输出信息：
			a. -q:指定jsp只输出进程ID
			b. -m:输出传递给Java进程的参数
			c. -l:输出主函数的完整路径
			d. -v:显示传递给Java虚拟机的参数

		B.虚拟机统计信息：jstat命令：用于观察Java堆信息的详细情况，基本使用语法位： jstat -<option> [-t] [-h<lines>] <vmid> [<interval>] [<count>]}，-t参数表示输出时间戳、-h参数表示在多少行后输出一个表头、vmid则是虚拟机的进程ID、interval和count表示输出间隔以及输出次数； option可以由以下值构成
			a. -class:监视类装载、卸载数量、总空间以及类装载所耗费的时间。
			b. -gc:监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。
			c. -gccapacity:监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。
			d. -gcutil:监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。
			e. -gccause:与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因。
			f. -gcnew:监视新生代GC状况
			g. -gcnewcapacity:监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间
			h. -gcold:监视老年代GC状况
			i. -gcoldcapacity:监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间
			j. -gcpermcapacity:输出永久代使用到的最大、最小空间
			k. -compiler:输出JIT编译器编译过的方法、耗时信息
			l. -printcompilation:输出已经被JIT编译的方法
		C.查看虚拟机参数：jinfo命令：查看正在运行的Java应用程序的扩展参数。基本语法是：jinfo <option> <pid>
		D.导出堆到文件：jmap命令：多功能命令，可以生成Java程序的Dump的文件，也可以查看堆内对象实例的统计信息、查看ClassLoader的信息以及finalizer队列 jmap [option] vmid
		E.堆分析工具：jhat命令：用于分析Java应用的堆快照内存
		F.查看线程堆栈：jstack命令：用于导出Java应用程序的线程堆栈。jstack [option] vmid
		G.远程主机信息收集：jstatd命令
		H.多功能命令行：jcmd命令：可以针对给定的Java虚拟机执行一条命令。
		I.性能统计工具：hprof		
